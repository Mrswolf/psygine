"""
Generated by AI.

You are an expert MRI physicist and Python developer. Write a single self‐contained Python module that defines:

    def generate_mri_coil_sensitivities(
        nx: int, ny: int, nz: int, ncoils: int,
        coil_radius: float = 0.1,         # meters
        decay_power: int = 3,             # exponent in 1/r^n
        smoothing_width: float = 0.2,     # fraction of coil_radius
        field_strength: float = 3.0,      # Tesla
        dielectric_map: Optional[np.ndarray] = None,
        mag_noise_std: float = 0.02,      # relative magnitude noise
        phase_noise_std: float = 0.05      # radians
    ) -> np.ndarray

It should return a 4D `complex64` NumPy array of shape `(ncoils, nz, ny, nx)` representing B₁⁺ sensitivity maps for a spherical loop‐coil array.

1. **Coil geometry & placement**
   - Position `ncoils` loops uniformly on a sphere of radius `coil_radius` using Fibonacci sampling.

2. **Magnitude model**
   - Compute decay ∝ 1/rᵈᵉᶜᵃʸ_power with Gaussian smoothing width = `smoothing_width * coil_radius`.
   - After generating the clean magnitude, add voxel‐wise relative Gaussian noise:
     `mag *= (1 + np.random.normal(0, mag_noise_std, mag.shape))`.

3. **Phase model**
   - Apply spherical‐wave phase `exp(–1j·k·r)` where
     `k = 2π·field_strength·γ/c` (γ=42.58e6 Hz/T, c=3e8 m/s), plus a coil‐specific offset.
   - After that, add voxel‐wise phase noise:
     `phase = np.angle(...) + np.random.normal(0, phase_noise_std, mag.shape)`.

4. **Dielectric loading**
   - If `dielectric_map` is provided (shape `(nz,ny,nx)`), multiply the *noisy* magnitude by it.

5. **Helper**
   - Include `show_coils(sens: np.ndarray)` to plot central slices of magnitude and phase for the first four coils.

6. **Documentation**
   - Include docstrings for all functions, including parameter types and return types. Explain the effect of each parameter.

Use only NumPy (and Matplotlib for plotting). Position arguments are only `nx, ny, nz, ncoils`; all physics parameters and noise levels are keyword arguments with sensible defaults. Produce only the module code (imports, functions, docstrings), no extra commentary.
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional


def generate_mri_coil_sensitivities(
    nx: int,
    ny: int,
    nz: int,
    ncoils: int,
    coil_radius: float = 0.1,
    decay_power: int = 3,
    smoothing_width: float = 0.2,
    field_strength: float = 3.0,
    dielectric_map: Optional[np.ndarray] = None,
    mag_noise_std: float = 0.02,
    phase_noise_std: float = 0.05,
) -> np.ndarray:
    """
    Generate noisy B1+ sensitivity maps for a spherical array of loop coils.

    Parameters
    ----------
    nx : int
        Number of voxels along the x-axis.
    ny : int
        Number of voxels along the y-axis.
    nz : int
        Number of voxels along the z-axis.
    ncoils : int
        Number of coil elements in the spherical array.
    coil_radius : float, optional
        Radius of the spherical coil array in meters.
        Larger values place coils farther from isocenter, reducing central amplitudes.
        Default: 0.1 m.
    decay_power : int, optional
        Exponent n in the distance decay term 1/r^n.
        Higher values make the field fall off more sharply.
        Default: 3 (dipole-like decay).
    smoothing_width : float, optional
        Gaussian smoothing width as a fraction of coil_radius.
        Controls extent of finite coil size: larger values broaden sensitivities.
        Default: 0.2.
    field_strength : float, optional
        Main magnetic field strength in Tesla.
        Used to compute phase wave number k = 2π * γ * B0 / c.
        Default: 3.0 T.
    dielectric_map : Optional[np.ndarray], optional
        3D map of relative permittivity of shape (nz, ny, nx).
        If provided, magnitude is voxel-wise multiplied by this map,
        simulating dielectric loading effects. Default: None.
    mag_noise_std : float, optional
        Standard deviation of relative Gaussian noise added to magnitude.
        mag *= (1 + noise). Default: 0.02 (2%).
    phase_noise_std : float, optional
        Standard deviation of additive Gaussian noise in phase (radians).
        Default: 0.05 rad.

    Returns
    -------
    sens : np.ndarray
        Complex sensitivity array of shape (ncoils, nz, ny, nx), dtype=complex64.
        Each entry sens[j, k, i, l] gives the simulated B1+ sensitivity
        of coil j at voxel (l, i, k), including noise.
    """
    # Physical constants
    gamma = 42.58e6  # Hz/T, gyromagnetic ratio
    c = 3e8  # m/s, speed of light
    k = 2 * np.pi * field_strength * gamma / c

    # Prepare voxel coordinate grids (in meters)
    xs = np.linspace(-coil_radius, coil_radius, nx)
    ys = np.linspace(-coil_radius, coil_radius, ny)
    zs = np.linspace(-coil_radius, coil_radius, nz)
    X, Y, Z = np.meshgrid(xs, ys, zs, indexing="xy")  # shapes: (ny, nx, nz)

    # Fibonacci-sphere coil placement
    idx = np.arange(ncoils, dtype=float) + 0.5
    phi = np.arccos(1 - 2 * idx / ncoils)
    theta = np.pi * (1 + 5**0.5) * idx
    cx = coil_radius * np.cos(theta) * np.sin(phi)
    cy = coil_radius * np.sin(theta) * np.sin(phi)
    cz = coil_radius * np.cos(phi)

    # Output container
    sens = np.zeros((ncoils, nz, ny, nx), dtype=np.complex64)
    eps = 1e-8
    sigma = smoothing_width * coil_radius

    # Loop over coils
    for j in range(ncoils):
        # Compute distance r from coil center to each voxel
        dx = X - cx[j]
        dy = Y - cy[j]
        dz = Z - cz[j]
        r = np.sqrt(dx * dx + dy * dy + dz * dz)

        # Magnitude: 1/r^decay_power with Gaussian smoothing
        mag = 1.0 / (r**decay_power + eps)
        mag *= np.exp(-(r**2) / (2 * sigma**2))
        # Dielectric loading modulation
        if dielectric_map is not None:
            mag *= dielectric_map.transpose(2, 1, 0)
        # Add relative magnitude noise
        mag *= 1 + np.random.normal(0, mag_noise_std, mag.shape)

        # Phase: spherical-wave term
        phase = np.angle(np.exp(-1j * k * r))
        # Add coil-specific offset
        phase += np.random.uniform(0, 2 * np.pi)
        # Add phase noise
        phase += np.random.normal(0, phase_noise_std, mag.shape)
        phasor = np.exp(1j * phase)

        vol = mag * phasor  # shape: (ny, nx, nz)
        # Store in output array with axes ordered (nz, ny, nx)
        sens[j] = np.transpose(vol, (2, 0, 1))

    return sens


def show_coils(sens: np.ndarray) -> None:
    """
    Quick-plot central slices of magnitude and phase for up to the first four coils.

    Parameters
    ----------
    sens : np.ndarray
        Complex sensitivity maps, shape (ncoils, nz, ny, nx).

    Returns
    -------
    None
    """
    ncoils, nz, ny, nx = sens.shape
    n_display = min(4, ncoils)
    cz = nz // 2

    fig, axes = plt.subplots(2, n_display, figsize=(3 * n_display, 6))
    for i in range(n_display):
        slice_data = sens[i, cz]
        mag = np.abs(slice_data)
        phs = np.angle(slice_data)

        ax_mag = axes[0, i]
        im1 = ax_mag.imshow(mag, origin="lower")
        ax_mag.set_title(f"Coil {i} Magnitude")
        ax_mag.axis("off")
        fig.colorbar(im1, ax=ax_mag, fraction=0.046, pad=0.04)

        ax_ph = axes[1, i]
        im2 = ax_ph.imshow(phs, origin="lower")
        ax_ph.set_title(f"Coil {i} Phase")
        ax_ph.axis("off")
        fig.colorbar(im2, ax=ax_ph, fraction=0.046, pad=0.04)

    plt.tight_layout()
    plt.show()
